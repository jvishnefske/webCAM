<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wasm Engineered Browser Computer-Aided Manufacturing</title>
<style>
:root {
  --bg: #0f1117;
  --surface: #1a1d27;
  --border: #2a2d3a;
  --accent: #4f8cff;
  --accent-dim: #2d5299;
  --text: #e0e0e8;
  --text-dim: #8888a0;
  --danger: #ff5555;
  --success: #55ff88;
  --mono: 'Courier New', monospace;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
}
header {
  background: var(--surface);
  border-bottom: 1px solid var(--border);
  padding: 12px 24px;
  display: flex;
  align-items: center;
  gap: 16px;
}
header h1 { font-size: 18px; font-weight: 600; }
header span { color: var(--text-dim); font-size: 13px; }
.app {
  display: grid;
  grid-template-columns: 320px 1fr 1fr;
  grid-template-rows: 1fr;
  height: calc(100vh - 49px);
}
/* ─ Sidebar ─ */
.sidebar {
  background: var(--surface);
  border-right: 1px solid var(--border);
  padding: 16px;
  overflow-y: auto;
}
.sidebar h2 { font-size: 13px; text-transform: uppercase; letter-spacing: 0.08em; color: var(--text-dim); margin-bottom: 12px; }
.sidebar section { margin-bottom: 20px; }
label { display: block; font-size: 13px; color: var(--text-dim); margin-bottom: 4px; }
input[type="number"], select, input[type="range"] {
  width: 100%;
  background: var(--bg);
  border: 1px solid var(--border);
  color: var(--text);
  padding: 6px 8px;
  border-radius: 4px;
  font-size: 13px;
  margin-bottom: 8px;
}
input[type="range"] { padding: 2px 0; border: none; background: transparent; }
input[type="number"]:focus, select:focus { outline: none; border-color: var(--accent); }
.drop-zone {
  border: 2px dashed var(--border);
  border-radius: 8px;
  padding: 32px 16px;
  text-align: center;
  cursor: pointer;
  transition: border-color 0.2s, background 0.2s;
  margin-bottom: 12px;
}
.drop-zone:hover, .drop-zone.drag-over {
  border-color: var(--accent);
  background: rgba(79,140,255,0.06);
}
.drop-zone p { font-size: 13px; color: var(--text-dim); }
.drop-zone .filename { color: var(--accent); font-weight: 600; margin-top: 8px; font-size: 14px; }
.btn {
  display: inline-block;
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.15s;
}
.btn-primary { background: var(--accent); color: #fff; width: 100%; }
.btn-primary:hover { background: var(--accent-dim); }
.btn-primary:disabled { opacity: 0.4; cursor: not-allowed; }
.btn-secondary { background: var(--border); color: var(--text); margin-top: 8px; width: 100%; }
.btn-secondary:hover { background: #3a3d4a; }
.btn-sm { padding: 4px 10px; font-size: 12px; width: auto; margin: 0; }
.status { font-size: 12px; margin-top: 8px; min-height: 16px; }
.status.error { color: var(--danger); }
.status.ok { color: var(--success); }
/* ─ Preview pane ─ */
.preview {
  background: var(--bg);
  display: flex;
  flex-direction: column;
  border-right: 1px solid var(--border);
}
.preview .pane-header {
  font-size: 13px; text-transform: uppercase; letter-spacing: 0.08em;
  color: var(--text-dim); padding: 12px 16px; border-bottom: 1px solid var(--border);
}
canvas { flex: 1; width: 100%; height: 100%; display: block; }
/* ─ Right pane (tabs) ─ */
.right-pane {
  background: var(--bg);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
.tab-bar {
  display: flex;
  border-bottom: 1px solid var(--border);
}
.tab-bar button {
  flex: 1;
  background: transparent;
  border: none;
  color: var(--text-dim);
  font-size: 13px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  padding: 10px 0;
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: color 0.15s, border-color 0.15s;
}
.tab-bar button.active {
  color: var(--accent);
  border-bottom-color: var(--accent);
}
.tab-content { flex: 1; display: none; flex-direction: column; overflow: hidden; }
.tab-content.active { display: flex; }
/* G-code tab */
.gcode-toolbar {
  display: flex; align-items: center; gap: 8px;
  padding: 8px 16px; border-bottom: 1px solid var(--border);
}
.gcode-toolbar .spacer { flex: 1; }
#gcode-output {
  flex: 1; background: var(--surface); color: var(--text); border: none;
  padding: 12px; font-family: var(--mono); font-size: 12px; line-height: 1.6;
  resize: none; overflow: auto;
}
/* Sim tab */
.sim-wrap { flex: 1; position: relative; }
.sim-wrap canvas { position: absolute; inset: 0; width: 100%; height: 100%; }
.sim-controls {
  display: flex; align-items: center; gap: 8px;
  padding: 8px 12px; border-top: 1px solid var(--border); background: var(--surface);
}
.sim-controls .spacer { flex: 1; }
.sim-controls .scrubber { flex: 3; }
.sim-info { font-size: 11px; color: var(--text-dim); min-width: 90px; text-align: right; font-family: var(--mono); }
/* ─ Responsive ─ */
@media (max-width: 900px) {
  .app { grid-template-columns: 1fr; grid-template-rows: auto 300px 1fr; }
  .preview, .right-pane { border-right: none; border-bottom: 1px solid var(--border); }
}
</style>
</head>
<body>

<header>
  <h1>Wasm Engineered Browser Computer-Aided Manufacturing</h1>
  <span>STL / SVG &rarr; G-code &mdash; runs entirely in your browser</span>
</header>

<div class="app">
  <!-- Sidebar -->
  <div class="sidebar">
    <section>
      <h2>Input File</h2>
      <div class="drop-zone" id="drop-zone">
        <p>Drop an <b>.stl</b> or <b>.svg</b> file here<br/>or click to browse</p>
        <div class="filename" id="filename"></div>
      </div>
      <input type="file" id="file-input" accept=".stl,.svg" hidden/>
    </section>
    <section>
      <h2>Strategy</h2>
      <select id="strategy">
        <option value="contour">Contour (profile cut)</option>
        <option value="pocket">Pocket (area clear)</option>
        <option value="slice">Slice (layer contour)</option>
        <option value="zigzag">Zigzag Surface</option>
        <option value="perimeter">Perimeter</option>
      </select>
    </section>
    <section>
      <h2>Tool</h2>
      <label>Tool type</label>
      <select id="tool-type">
        <option value="end_mill">End Mill</option>
        <option value="ball_end">Ball End</option>
        <option value="face_mill">Face Mill</option>
      </select>
      <label>Tool diameter (mm)</label>
      <input type="number" id="tool-diameter" value="3.175" step="0.1" min="0.1"/>
      <div id="effective-diameter-row" style="display:none;">
        <label>Effective diameter (mm)</label>
        <input type="number" id="effective-diameter" value="3.175" step="0.1" min="0.1"/>
      </div>
      <div id="corner-radius-row" style="display:none;">
        <label>Corner radius (mm)</label>
        <input type="number" id="corner-radius" value="0" step="0.1" min="0"/>
      </div>
      <label>Step-over (mm)</label>
      <input type="number" id="step-over" value="1.5" step="0.1" min="0.1"/>
    </section>
    <section id="zigzag-options" style="display:none;">
      <h2>Zigzag Options</h2>
      <label>Scan direction</label>
      <select id="scan-direction">
        <option value="x">X (rows along X)</option>
        <option value="y">Y (rows along Y)</option>
      </select>
    </section>
    <section id="perimeter-options" style="display:none;">
      <h2>Perimeter Options</h2>
      <label>
        <input type="checkbox" id="climb-cut"/>
        Climb cutting
      </label>
      <label>Number of passes</label>
      <input type="number" id="perimeter-passes" value="1" step="1" min="1"/>
    </section>
    <section>
      <h2>Cutting</h2>
      <label>Cut depth (mm, negative)</label>
      <input type="number" id="cut-depth" value="-1" step="0.5"/>
      <label>Step-down per pass (mm)</label>
      <input type="number" id="step-down" value="1" step="0.25" min="0.1"/>
      <label>Feed rate (mm/min)</label>
      <input type="number" id="feed-rate" value="800" step="50" min="1"/>
      <label>Plunge rate (mm/min)</label>
      <input type="number" id="plunge-rate" value="300" step="50" min="1"/>
      <label>Spindle speed (RPM)</label>
      <input type="number" id="spindle-speed" value="12000" step="500" min="0"/>
      <label>Safe Z (mm)</label>
      <input type="number" id="safe-z" value="5" step="1" min="0.5"/>
    </section>
    <section>
      <button class="btn btn-primary" id="generate-btn" disabled>Generate G-code</button>
      <div class="status" id="status"></div>
    </section>
  </div>

  <!-- Preview canvas -->
  <div class="preview">
    <div class="pane-header">Toolpath Preview</div>
    <canvas id="preview-canvas"></canvas>
  </div>

  <!-- Right pane: G-code + Simulation tabs -->
  <div class="right-pane">
    <div class="tab-bar">
      <button class="active" data-tab="gcode-tab">G-code</button>
      <button data-tab="sim-tab">Simulation</button>
    </div>

    <!-- G-code tab -->
    <div class="tab-content active" id="gcode-tab">
      <div class="gcode-toolbar">
        <div class="spacer"></div>
        <button class="btn btn-sm btn-secondary" id="copy-btn">Copy</button>
        <button class="btn btn-sm btn-secondary" id="download-btn">Download .nc</button>
      </div>
      <textarea id="gcode-output" readonly placeholder="G-code will appear here after generation..."></textarea>
    </div>

    <!-- Simulation tab -->
    <div class="tab-content" id="sim-tab">
      <div class="sim-wrap">
        <canvas id="sim-canvas"></canvas>
      </div>
      <div class="sim-controls">
        <button class="btn btn-sm btn-secondary" id="sim-play">Play</button>
        <button class="btn btn-sm btn-secondary" id="sim-reset">Reset</button>
        <label style="margin:0;font-size:11px;min-width:50px">Speed</label>
        <input type="range" id="sim-speed" min="1" max="200" value="50" style="width:80px;flex:0 0 80px"/>
        <input type="range" class="scrubber" id="sim-scrub" min="0" max="1" step="0.001" value="0"/>
        <div class="sim-info" id="sim-info">0 / 0</div>
      </div>
    </div>
  </div>
</div>

<script type="module">
import init, {
  process_stl, process_svg,
  preview_stl, preview_svg,
  sim_moves_stl, sim_moves_svg,
} from './pkg/rustcam.js';

let wasmReady = false;
let fileData = null;
let fileType = null;

const dropZone    = document.getElementById('drop-zone');
const fileInput   = document.getElementById('file-input');
const filenameEl  = document.getElementById('filename');
const generateBtn = document.getElementById('generate-btn');
const statusEl    = document.getElementById('status');
const gcodeOut    = document.getElementById('gcode-output');
const canvas      = document.getElementById('preview-canvas');
const copyBtn     = document.getElementById('copy-btn');
const downloadBtn = document.getElementById('download-btn');

// ── Tool type UI ──────────────────────────────────────────────────────
const toolTypeSelect = document.getElementById('tool-type');
const effectiveDiameterRow = document.getElementById('effective-diameter-row');
const cornerRadiusRow = document.getElementById('corner-radius-row');

function updateToolTypeUI() {
  const toolType = toolTypeSelect.value;
  effectiveDiameterRow.style.display = toolType === 'face_mill' ? 'block' : 'none';
  cornerRadiusRow.style.display = toolType === 'ball_end' ? 'block' : 'none';
  // For ball end, update corner radius to match radius
  if (toolType === 'ball_end') {
    const diameter = parseFloat(document.getElementById('tool-diameter').value);
    document.getElementById('corner-radius').value = (diameter / 2).toFixed(2);
  }
}

toolTypeSelect.addEventListener('change', updateToolTypeUI);
document.getElementById('tool-diameter').addEventListener('change', updateToolTypeUI);

// ── Strategy UI ───────────────────────────────────────────────────────
const strategySelect = document.getElementById('strategy');
const perimeterOptions = document.getElementById('perimeter-options');
const zigzagOptions = document.getElementById('zigzag-options');

function updateStrategyUI() {
  const strategy = strategySelect.value;
  perimeterOptions.style.display = strategy === 'perimeter' ? 'block' : 'none';
  zigzagOptions.style.display = strategy === 'zigzag' ? 'block' : 'none';
}

strategySelect.addEventListener('change', () => { updateStrategyUI(); tryPreview(); });
document.getElementById('scan-direction').addEventListener('change', tryPreview);
updateStrategyUI();

// ── Tabs ─────────────────────────────────────────────────────────────
document.querySelectorAll('.tab-bar button').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tab-bar button').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById(btn.dataset.tab).classList.add('active');
    if (btn.dataset.tab === 'sim-tab') resizeSim();
  });
});

// ── Init WASM ────────────────────────────────────────────────────────
async function boot() {
  try {
    await init();
    wasmReady = true;
    statusEl.textContent = 'WASM loaded — drop a file to begin.';
    statusEl.className = 'status ok';
  } catch(e) {
    statusEl.textContent = 'Failed to load WASM: ' + e;
    statusEl.className = 'status error';
  }
}
boot();

// ── File handling ────────────────────────────────────────────────────
dropZone.addEventListener('click', () => fileInput.click());
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('drag-over'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('drag-over'));
dropZone.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('drag-over');
  if (e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
});
fileInput.addEventListener('change', () => { if (fileInput.files.length) handleFile(fileInput.files[0]); });

function handleFile(file) {
  const ext = file.name.split('.').pop().toLowerCase();
  if (ext === 'stl') {
    fileType = 'stl';
    file.arrayBuffer().then(buf => {
      fileData = new Uint8Array(buf);
      filenameEl.textContent = file.name;
      generateBtn.disabled = !wasmReady;
      tryPreview();
    });
  } else if (ext === 'svg') {
    fileType = 'svg';
    file.text().then(txt => {
      fileData = txt;
      filenameEl.textContent = file.name;
      generateBtn.disabled = !wasmReady;
      tryPreview();
    });
  } else {
    statusEl.textContent = 'Unsupported file type: .' + ext;
    statusEl.className = 'status error';
  }
}

// ── Config ───────────────────────────────────────────────────────────
function getConfig() {
  const toolType = document.getElementById('tool-type').value;
  const config = {
    tool_diameter:  parseFloat(document.getElementById('tool-diameter').value),
    step_over:      parseFloat(document.getElementById('step-over').value),
    step_down:      parseFloat(document.getElementById('step-down').value),
    feed_rate:      parseFloat(document.getElementById('feed-rate').value),
    plunge_rate:    parseFloat(document.getElementById('plunge-rate').value),
    spindle_speed:  parseFloat(document.getElementById('spindle-speed').value),
    safe_z:         parseFloat(document.getElementById('safe-z').value),
    cut_depth:      parseFloat(document.getElementById('cut-depth').value),
    strategy:       document.getElementById('strategy').value,
    tool_type:      toolType,
  };
  // Add tool-type-specific parameters
  if (toolType === 'ball_end') {
    config.corner_radius = parseFloat(document.getElementById('corner-radius').value) || 0;
  } else if (toolType === 'face_mill') {
    config.effective_diameter = parseFloat(document.getElementById('effective-diameter').value) || config.tool_diameter;
  }
  // Add zigzag-specific parameters
  if (config.strategy === 'zigzag') {
    config.scan_direction = document.getElementById('scan-direction').value;
  }
  // Add perimeter-specific parameters
  if (config.strategy === 'perimeter') {
    config.climb_cut = document.getElementById('climb-cut').checked;
    config.perimeter_passes = parseInt(document.getElementById('perimeter-passes').value) || 1;
  }
  return JSON.stringify(config);
}

// ── Preview ──────────────────────────────────────────────────────────
function tryPreview() {
  if (!wasmReady || !fileData) return;
  try {
    let json;
    if (fileType === 'stl') json = preview_stl(fileData, getConfig());
    else json = preview_svg(fileData);
    drawPreview(JSON.parse(json));
  } catch(e) { console.warn('Preview error:', e); }
}

function drawPreview(paths) {
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width  = rect.width  * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  ctx.clearRect(0, 0, rect.width, rect.height);
  if (!paths.length) return;

  // Detect if paths have Z coordinates (3D format)
  const has3D = paths.some(p => p.length > 0 && p[0].length >= 3);

  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  let minZ=Infinity, maxZ=-Infinity;
  for (const p of paths) for (const pt of p) {
    const [x, y, z] = pt;
    if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y;
    if (has3D && z !== undefined) {
      if(z<minZ)minZ=z; if(z>maxZ)maxZ=z;
    }
  }
  let w=maxX-minX, h=maxY-minY;
  // Handle degenerate bounds (single point or line): expand the flat
  // dimension so the plot is centered rather than scaled to 1 model-unit.
  if (w === 0 && h === 0) { w = 1; h = 1; }
  else if (w === 0) { w = h; minX -= w/2; maxX += w/2; }
  else if (h === 0) { h = w; minY -= h/2; maxY += h/2; }
  const zRange = (maxZ - minZ) || 1;
  // Use percentage-based padding that won't overwhelm small canvases
  const pad = Math.max(8, Math.min(30, Math.min(rect.width, rect.height) * 0.08));
  const availW = Math.max(rect.width - pad*2, 1);
  const availH = Math.max(rect.height - pad*2, 1);
  const scale = Math.min(availW/w, availH/h);
  const offX = pad+(availW-w*scale)/2;
  const offY = pad+(availH-h*scale)/2;
  const tx = x => offX+(x-minX)*scale;
  const ty = y => offY+(maxY-y)*scale;

  // Color gradient by Z height (blue=low, green=mid, yellow=high)
  const zColor = (z) => {
    if (!has3D || z === undefined) return '#4f8cff';
    const t = (z - minZ) / zRange; // 0 to 1
    // HSL: 240 (blue) -> 120 (green) -> 60 (yellow)
    const hue = 240 - t * 180;
    return `hsl(${hue}, 80%, 55%)`;
  };

  ctx.strokeStyle='#1a1d27'; ctx.lineWidth=0.5;
  const gs=Math.pow(10,Math.floor(Math.log10(Math.max(w,h))));
  for(let x=Math.floor(minX/gs)*gs;x<=maxX;x+=gs){ctx.beginPath();ctx.moveTo(tx(x),0);ctx.lineTo(tx(x),rect.height);ctx.stroke();}
  for(let y=Math.floor(minY/gs)*gs;y<=maxY;y+=gs){ctx.beginPath();ctx.moveTo(0,ty(y));ctx.lineTo(rect.width,ty(y));ctx.stroke();}

  ctx.lineWidth=1.2; ctx.lineJoin='round';
  for(const p of paths){
    if(p.length<2)continue;
    if (has3D) {
      // Draw segments with Z-based color gradient
      for(let i=1;i<p.length;i++){
        const z = p[i][2];
        ctx.strokeStyle = zColor(z);
        ctx.beginPath();
        ctx.moveTo(tx(p[i-1][0]),ty(p[i-1][1]));
        ctx.lineTo(tx(p[i][0]),ty(p[i][1]));
        ctx.stroke();
      }
    } else {
      // 2D paths: single color
      ctx.strokeStyle='#4f8cff';
      ctx.beginPath();
      ctx.moveTo(tx(p[0][0]),ty(p[0][1]));
      for(let i=1;i<p.length;i++)ctx.lineTo(tx(p[i][0]),ty(p[i][1]));
      ctx.stroke();
    }
  }
}

window.addEventListener('resize', () => { tryPreview(); resizeSim(); });

// ── Generate (via Web Worker for progress reporting) ─────────────────
let genWorker = null;
let genStartTime = 0;

function initWorker() {
  genWorker = new Worker('./generate-worker.js', { type: 'module' });
  genWorker.onmessage = (evt) => {
    const msg = evt.data;
    if (msg.type === 'ready') {
      // Worker WASM loaded — nothing to do, main WASM already controls the button
    } else if (msg.type === 'progress') {
      const elapsed = ((performance.now() - genStartTime) / 1000).toFixed(1);
      statusEl.textContent = `Generating... layer ${msg.completed} / ${msg.total}  (${elapsed}s)`;
      statusEl.className = 'status';
    } else if (msg.type === 'done') {
      gcodeOut.value = msg.gcode;
      const elapsed = ((performance.now() - genStartTime) / 1000).toFixed(1);
      statusEl.textContent = `Done — ${msg.gcode.split('\n').length} lines of G-code in ${elapsed}s.`;
      statusEl.className = 'status ok';
      generateBtn.disabled = false;
      tryPreview();
      loadSim();
    } else if (msg.type === 'error') {
      statusEl.textContent = 'Error: ' + msg.error;
      statusEl.className = 'status error';
      generateBtn.disabled = false;
    }
  };
  genWorker.onerror = (e) => {
    statusEl.textContent = 'Worker error: ' + e.message;
    statusEl.className = 'status error';
    generateBtn.disabled = false;
  };
}

// Try to start the worker; if module workers aren't supported, fall back
// to running generation on the main thread (old behaviour).
let workerSupported = true;
try {
  initWorker();
} catch(e) {
  workerSupported = false;
  console.warn('Module workers not supported, using main-thread generation:', e);
}

generateBtn.addEventListener('click', () => {
  if (!wasmReady || !fileData) return;
  generateBtn.disabled = true;
  statusEl.textContent = 'Generating... layer 0 / ?';
  statusEl.className = 'status';
  genStartTime = performance.now();

  const cfg = getConfig();

  if (workerSupported && genWorker) {
    genWorker.postMessage({ fileData, fileType, configJson: cfg });
  } else {
    // Fallback: run synchronously on main thread
    try {
      let gcode;
      if (fileType === 'stl') gcode = process_stl(fileData, cfg);
      else gcode = process_svg(fileData, cfg);
      gcodeOut.value = gcode;
      const elapsed = ((performance.now() - genStartTime) / 1000).toFixed(1);
      statusEl.textContent = `Done — ${gcode.split('\n').length} lines of G-code in ${elapsed}s.`;
      statusEl.className = 'status ok';
      tryPreview();
      loadSim();
    } catch(e) {
      statusEl.textContent = 'Error: ' + e;
      statusEl.className = 'status error';
    }
    generateBtn.disabled = false;
  }
});

// ── Copy / Download ──────────────────────────────────────────────────
copyBtn.addEventListener('click', () => {
  navigator.clipboard.writeText(gcodeOut.value).then(() => {
    copyBtn.textContent = 'Copied!';
    setTimeout(() => copyBtn.textContent = 'Copy', 1500);
  });
});
downloadBtn.addEventListener('click', () => {
  const blob = new Blob([gcodeOut.value], {type:'text/plain'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = (filenameEl.textContent||'output').replace(/\.\w+$/,'') + '.nc';
  a.click(); URL.revokeObjectURL(a.href);
});

// =====================================================================
//  TOOL SIMULATION
// =====================================================================
const simCanvas  = document.getElementById('sim-canvas');
const simPlay    = document.getElementById('sim-play');
const simReset   = document.getElementById('sim-reset');
const simSpeed   = document.getElementById('sim-speed');
const simScrub   = document.getElementById('sim-scrub');
const simInfo    = document.getElementById('sim-info');

let simMoves   = [];       // [{x,y,z,rapid}, ...]
let simIdx     = 0;        // current move index (how far we've drawn)
let simRunning = false;
let simRaf     = null;
let simBounds  = null;     // {minX,minY,maxX,maxY,w,h}
let simScale   = 1;
let simOffX    = 0;
let simOffY    = 0;

// Off-screen canvas for accumulated material-removal strokes
let matCanvas = null;
let matCtx    = null;

function loadSim() {
  try {
    const cfg = getConfig();
    let json;
    if (fileType === 'stl') json = sim_moves_stl(fileData, cfg);
    else json = sim_moves_svg(fileData, cfg);
    simMoves = JSON.parse(json);
  } catch(e) { simMoves = []; console.warn('sim_moves error:', e); }
  simIdx = 0;
  simScrub.max = Math.max(simMoves.length - 1, 1);
  simScrub.value = 0;
  simInfo.textContent = `0 / ${simMoves.length}`;
  simRunning = false;
  simPlay.textContent = 'Play';
  computeSimBounds();
  initMatCanvas();
  drawSimFrame();
}

function computeSimBounds() {
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for (const m of simMoves) {
    if(m.x<minX)minX=m.x; if(m.y<minY)minY=m.y;
    if(m.x>maxX)maxX=m.x; if(m.y>maxY)maxY=m.y;
  }
  if (!simMoves.length) { minX=0;minY=0;maxX=10;maxY=10; }
  let w=maxX-minX, h=maxY-minY;
  if (w === 0 && h === 0) { w = 1; h = 1; }
  else if (w === 0) { w = h; minX -= w/2; maxX += w/2; }
  else if (h === 0) { h = w; minY -= h/2; maxY += h/2; }
  simBounds = {minX,minY,maxX,maxY,w,h};
}

function resizeSim() {
  if (!simBounds) return;
  const rect = simCanvas.getBoundingClientRect();
  if (rect.width < 1 || rect.height < 1) return;
  const dpr = window.devicePixelRatio || 1;
  simCanvas.width  = rect.width  * dpr;
  simCanvas.height = rect.height * dpr;
  const pad = Math.max(8, Math.min(40, Math.min(rect.width, rect.height) * 0.08));
  const availW = Math.max(rect.width - pad*2, 1);
  const availH = Math.max(rect.height - pad*2, 1);
  simScale = Math.min(availW/simBounds.w, availH/simBounds.h);
  simOffX = pad + (availW-simBounds.w*simScale)/2;
  simOffY = pad + (availH-simBounds.h*simScale)/2;
  // Rebuild material canvas at new size
  initMatCanvas();
  replayMat(simIdx);
  drawSimFrame();
}

function initMatCanvas() {
  const rect = simCanvas.getBoundingClientRect();
  if (rect.width < 1) return;
  const dpr = window.devicePixelRatio || 1;
  matCanvas = document.createElement('canvas');
  matCanvas.width  = rect.width * dpr;
  matCanvas.height = rect.height * dpr;
  matCtx = matCanvas.getContext('2d');
}

function simTx(x) { return (simOffX + (x - simBounds.minX)*simScale); }
function simTy(y) { return (simOffY + (simBounds.maxY - y)*simScale); }

// Stamp one material-removal circle between two cut moves
function stampMat(ax, ay, bx, by, toolR) {
  if (!matCtx) return;
  const dpr = window.devicePixelRatio || 1;
  matCtx.save();
  matCtx.scale(dpr, dpr);
  matCtx.strokeStyle = 'rgba(255,80,80,0.35)';
  matCtx.lineWidth = toolR * simScale * 2;
  matCtx.lineCap = 'round';
  matCtx.beginPath();
  matCtx.moveTo(simTx(ax), simTy(ay));
  matCtx.lineTo(simTx(bx), simTy(by));
  matCtx.stroke();
  matCtx.restore();
}

// Re-draw material removal from scratch up to index n (used after resize / scrub)
function replayMat(n) {
  if (!matCtx) return;
  matCtx.clearRect(0, 0, matCanvas.width, matCanvas.height);
  const toolR = parseFloat(document.getElementById('tool-diameter').value) / 2;
  const safeZ = parseFloat(document.getElementById('safe-z').value);
  for (let i = 1; i <= n && i < simMoves.length; i++) {
    const prev = simMoves[i-1];
    const cur  = simMoves[i];
    if (!cur.rapid && cur.z < safeZ - 0.01) {
      stampMat(prev.x, prev.y, cur.x, cur.y, toolR);
    }
  }
}

function drawSimFrame() {
  const ctx = simCanvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const rect = simCanvas.getBoundingClientRect();
  if (rect.width < 1) return;
  ctx.save();
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  ctx.clearRect(0, 0, rect.width, rect.height);

  // Stock outline
  if (simBounds) {
    ctx.strokeStyle = '#2a2d3a';
    ctx.lineWidth = 1;
    ctx.strokeRect(
      simTx(simBounds.minX) - 4, simTy(simBounds.maxY) - 4,
      simBounds.w * simScale + 8, simBounds.h * simScale + 8
    );
  }

  // Material removal layer
  if (matCanvas) ctx.drawImage(matCanvas, 0, 0, matCanvas.width/dpr, matCanvas.height/dpr);

  // Draw completed toolpath lines
  if (simMoves.length > 1 && simIdx > 0) {
    const safeZ = parseFloat(document.getElementById('safe-z').value);
    ctx.lineWidth = 0.8;
    ctx.lineJoin = 'round';
    for (let i = 1; i <= simIdx && i < simMoves.length; i++) {
      const prev = simMoves[i-1];
      const cur = simMoves[i];
      ctx.strokeStyle = cur.rapid ? 'rgba(255,255,100,0.25)' : 'rgba(79,140,255,0.6)';
      ctx.beginPath();
      ctx.moveTo(simTx(prev.x), simTy(prev.y));
      ctx.lineTo(simTx(cur.x), simTy(cur.y));
      ctx.stroke();
    }
  }

  // Tool head
  if (simIdx < simMoves.length) {
    const m = simMoves[simIdx];
    const toolR = parseFloat(document.getElementById('tool-diameter').value) / 2;
    const r = toolR * simScale;
    const cx = simTx(m.x), cy = simTy(m.y);
    // Shadow
    ctx.beginPath();
    ctx.arc(cx, cy, r + 2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fill();
    // Tool body
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    const cutting = !m.rapid && m.z < parseFloat(document.getElementById('safe-z').value) - 0.01;
    ctx.fillStyle = cutting ? 'rgba(255,80,80,0.7)' : 'rgba(100,200,100,0.5)';
    ctx.strokeStyle = cutting ? '#ff5555' : '#55ff88';
    ctx.lineWidth = 1.5;
    ctx.fill();
    ctx.stroke();
    // Centre dot
    ctx.beginPath();
    ctx.arc(cx, cy, 2, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.fill();
    // Z label
    ctx.fillStyle = '#8888a0';
    ctx.font = '11px monospace';
    ctx.fillText(`Z${m.z.toFixed(2)}`, cx + r + 6, cy + 4);
  }

  ctx.restore();
  simInfo.textContent = `${simIdx} / ${simMoves.length}`;
}

// ── Simulation transport ─────────────────────────────────────────────
simPlay.addEventListener('click', () => {
  if (!simMoves.length) return;
  simRunning = !simRunning;
  simPlay.textContent = simRunning ? 'Pause' : 'Play';
  if (simRunning) simTick();
});

simReset.addEventListener('click', () => {
  simRunning = false;
  simPlay.textContent = 'Play';
  if (simRaf) cancelAnimationFrame(simRaf);
  simIdx = 0;
  simScrub.value = 0;
  initMatCanvas();
  drawSimFrame();
});

simScrub.addEventListener('input', () => {
  const target = parseInt(simScrub.value);
  simIdx = target;
  replayMat(simIdx);
  drawSimFrame();
});

function simTick() {
  if (!simRunning) return;
  const speed = parseInt(simSpeed.value);
  const safeZ = parseFloat(document.getElementById('safe-z').value);
  const toolR = parseFloat(document.getElementById('tool-diameter').value) / 2;
  // Advance multiple moves per frame at higher speeds
  const steps = Math.max(1, Math.round(speed / 10));
  for (let s = 0; s < steps; s++) {
    if (simIdx >= simMoves.length - 1) {
      simRunning = false;
      simPlay.textContent = 'Play';
      break;
    }
    simIdx++;
    const prev = simMoves[simIdx - 1];
    const cur  = simMoves[simIdx];
    if (!cur.rapid && cur.z < safeZ - 0.01) {
      stampMat(prev.x, prev.y, cur.x, cur.y, toolR);
    }
  }
  simScrub.value = simIdx;
  drawSimFrame();
  if (simRunning) simRaf = requestAnimationFrame(simTick);
}
</script>
</body>
</html>
